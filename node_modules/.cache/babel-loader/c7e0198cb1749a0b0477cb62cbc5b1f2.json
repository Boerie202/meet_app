{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport './_version.js';\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link module:workbox-routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof module:workbox-routing\n */\n\nclass Router {\n  /**\n   * Initializes a new Router.\n   */\n  constructor() {\n    this._routes = new Map();\n  }\n  /**\n   * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n\n\n  get routes() {\n    return this._routes;\n  }\n  /**\n   * Adds a fetch event listener to respond to events when a route matches\n   * the event's request.\n   */\n\n\n  addFetchListener() {\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n    self.addEventListener('fetch', event => {\n      const {\n        request\n      } = event;\n      const responsePromise = this.handleRequest({\n        request,\n        event\n      });\n\n      if (responsePromise) {\n        event.respondWith(responsePromise);\n      }\n    });\n  }\n  /**\n   * Adds a message event listener for URLs to cache from the window.\n   * This is useful to cache resources loaded on the page prior to when the\n   * service worker started controlling it.\n   *\n   * The format of the message data sent from the window should be as follows.\n   * Where the `urlsToCache` array may consist of URL strings or an array of\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n   *\n   * ```\n   * {\n   *   type: 'CACHE_URLS',\n   *   payload: {\n   *     urlsToCache: [\n   *       './script1.js',\n   *       './script2.js',\n   *       ['./script3.js', {mode: 'no-cors'}],\n   *     ],\n   *   },\n   * }\n   * ```\n   */\n\n\n  addCacheListener() {\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n    self.addEventListener('message', event => {\n      if (event.data && event.data.type === 'CACHE_URLS') {\n        const {\n          payload\n        } = event.data;\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n        }\n\n        const requestPromises = Promise.all(payload.urlsToCache.map(entry => {\n          if (typeof entry === 'string') {\n            entry = [entry];\n          }\n\n          const request = new Request(...entry);\n          return this.handleRequest({\n            request\n          }); // TODO(philipwalton): TypeScript errors without this typecast for\n          // some reason (probably a bug). The real type here should work but\n          // doesn't: `Array<Promise<Response> | undefined>`.\n        })); // TypeScript\n\n        event.waitUntil(requestPromises); // If a MessageChannel was used, reply to the message on success.\n\n        if (event.ports && event.ports[0]) {\n          requestPromises.then(() => event.ports[0].postMessage(true));\n        }\n      }\n    });\n  }\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to handle (this is usually\n   *     from a fetch event, but it does not have to be).\n   * @param {FetchEvent} [options.event] The event that triggered the request,\n   *     if applicable.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   *     registered route can handle the request. If there is no matching\n   *     route and there's no `defaultHandler`, `undefined` is returned.\n   */\n\n\n  handleRequest(_ref) {\n    let {\n      request,\n      event\n    } = _ref;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'handleRequest',\n        paramName: 'options.request'\n      });\n    }\n\n    const url = new URL(request.url, location.href);\n\n    if (!url.protocol.startsWith('http')) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n      }\n\n      return;\n    }\n\n    const {\n      params,\n      route\n    } = this.findMatchingRoute({\n      url,\n      request,\n      event\n    });\n    let handler = route && route.handler;\n    const debugMessages = [];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (handler) {\n        debugMessages.push([`Found a route to handle this request:`, route]);\n\n        if (params) {\n          debugMessages.push([`Passing the following params to the route's handler:`, params]);\n        }\n      }\n    } // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n\n\n    if (!handler && this._defaultHandler) {\n      if (process.env.NODE_ENV !== 'production') {\n        debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler.`);\n      }\n\n      handler = this._defaultHandler;\n    }\n\n    if (!handler) {\n      if (process.env.NODE_ENV !== 'production') {\n        // No handler so Workbox will do nothing. If logs is set of debug\n        // i.e. verbose, we should print out this information.\n        logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n      }\n\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // We have a handler, meaning Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n      debugMessages.forEach(msg => {\n        if (Array.isArray(msg)) {\n          logger.log(...msg);\n        } else {\n          logger.log(msg);\n        }\n      });\n      logger.groupEnd();\n    } // Wrap in try and catch in case the handle method throws a synchronous\n    // error. It should still callback to the catch handler.\n\n\n    let responsePromise;\n\n    try {\n      responsePromise = handler.handle({\n        url,\n        request,\n        event,\n        params\n      });\n    } catch (err) {\n      responsePromise = Promise.reject(err);\n    }\n\n    if (responsePromise instanceof Promise && this._catchHandler) {\n      responsePromise = responsePromise.catch(err => {\n        if (process.env.NODE_ENV !== 'production') {\n          // Still include URL here as it will be async from the console group\n          // and may not make sense without the URL\n          logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\n          logger.error(`Error thrown by:`, route);\n          logger.error(err);\n          logger.groupEnd();\n        }\n\n        return this._catchHandler.handle({\n          url,\n          request,\n          event\n        });\n      });\n    }\n\n    return responsePromise;\n  }\n  /**\n   * Checks a request and URL (and optionally an event) against the list of\n   * registered routes, and if there's a match, returns the corresponding\n   * route along with any params generated by the match.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {Request} options.request The request to match.\n   * @param {Event} [options.event] The corresponding event (unless N/A).\n   * @return {Object} An object with `route` and `params` properties.\n   *     They are populated if a matching route was found or `undefined`\n   *     otherwise.\n   */\n\n\n  findMatchingRoute(_ref2) {\n    let {\n      url,\n      request,\n      event\n    } = _ref2;\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(url, URL, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.url'\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'findMatchingRoute',\n        paramName: 'options.request'\n      });\n    }\n\n    const routes = this._routes.get(request.method) || [];\n\n    for (const route of routes) {\n      let params;\n      const matchResult = route.match({\n        url,\n        request,\n        event\n      });\n\n      if (matchResult) {\n        // See https://github.com/GoogleChrome/workbox/issues/2079\n        params = matchResult;\n\n        if (Array.isArray(matchResult) && matchResult.length === 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          params = undefined;\n        } else if (matchResult.constructor === Object && Object.keys(matchResult).length === 0) {\n          // Instead of passing an empty object in as params, use undefined.\n          params = undefined;\n        } else if (typeof matchResult === 'boolean') {\n          // For the boolean value true (rather than just something truth-y),\n          // don't set params.\n          // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n          params = undefined;\n        } // Return early if have a match.\n\n\n        return {\n          route,\n          params\n        };\n      }\n    } // If no match was found above, return and empty object.\n\n\n    return {};\n  }\n  /**\n   * Define a default `handler` that's called when no routes explicitly\n   * match the incoming request.\n   *\n   * Without a default handler, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @param {module:workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n\n\n  setDefaultHandler(handler) {\n    this._defaultHandler = normalizeHandler(handler);\n  }\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @param {module:workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n\n\n  setCatchHandler(handler) {\n    this._catchHandler = normalizeHandler(handler);\n  }\n  /**\n   * Registers a route with the router.\n   *\n   * @param {module:workbox-routing.Route} route The route to register.\n   */\n\n\n  registerRoute(route) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(route, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.hasMethod(route, 'match', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.isType(route.handler, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.hasMethod(route.handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.handler'\n      });\n      assert.isType(route.method, 'string', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.method'\n      });\n    }\n\n    if (!this._routes.has(route.method)) {\n      this._routes.set(route.method, []);\n    } // Give precedence to all of the earlier routes by adding this additional\n    // route to the end of the array.\n\n\n    this._routes.get(route.method).push(route);\n  }\n  /**\n   * Unregisters a route with the router.\n   *\n   * @param {module:workbox-routing.Route} route The route to unregister.\n   */\n\n\n  unregisterRoute(route) {\n    if (!this._routes.has(route.method)) {\n      throw new WorkboxError('unregister-route-but-not-found-with-method', {\n        method: route.method\n      });\n    }\n\n    const routeIndex = this._routes.get(route.method).indexOf(route);\n\n    if (routeIndex > -1) {\n      this._routes.get(route.method).splice(routeIndex, 1);\n    } else {\n      throw new WorkboxError('unregister-route-route-not-registered');\n    }\n  }\n\n}\n\nexport { Router };","map":{"version":3,"names":["assert","logger","WorkboxError","getFriendlyURL","normalizeHandler","Router","constructor","_routes","Map","routes","addFetchListener","self","addEventListener","event","request","responsePromise","handleRequest","respondWith","addCacheListener","data","type","payload","process","env","NODE_ENV","debug","urlsToCache","requestPromises","Promise","all","map","entry","Request","waitUntil","ports","then","postMessage","isInstance","moduleName","className","funcName","paramName","url","URL","location","href","protocol","startsWith","params","route","findMatchingRoute","handler","debugMessages","push","_defaultHandler","groupCollapsed","forEach","msg","Array","isArray","log","groupEnd","handle","err","reject","_catchHandler","catch","error","get","method","matchResult","match","length","undefined","Object","keys","setDefaultHandler","setCatchHandler","registerRoute","isType","hasMethod","has","set","unregisterRoute","routeIndex","indexOf","splice"],"sources":["C:/Users/matth/Documents/careerfoundry/meet_app/meet/node_modules/workbox-routing/Router.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport './_version.js';\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link module:workbox-routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof module:workbox-routing\n */\nclass Router {\n    /**\n     * Initializes a new Router.\n     */\n    constructor() {\n        this._routes = new Map();\n    }\n    /**\n     * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP\n     * method name ('GET', etc.) to an array of all the corresponding `Route`\n     * instances that are registered.\n     */\n    get routes() {\n        return this._routes;\n    }\n    /**\n     * Adds a fetch event listener to respond to events when a route matches\n     * the event's request.\n     */\n    addFetchListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('fetch', ((event) => {\n            const { request } = event;\n            const responsePromise = this.handleRequest({ request, event });\n            if (responsePromise) {\n                event.respondWith(responsePromise);\n            }\n        }));\n    }\n    /**\n     * Adds a message event listener for URLs to cache from the window.\n     * This is useful to cache resources loaded on the page prior to when the\n     * service worker started controlling it.\n     *\n     * The format of the message data sent from the window should be as follows.\n     * Where the `urlsToCache` array may consist of URL strings or an array of\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n     *\n     * ```\n     * {\n     *   type: 'CACHE_URLS',\n     *   payload: {\n     *     urlsToCache: [\n     *       './script1.js',\n     *       './script2.js',\n     *       ['./script3.js', {mode: 'no-cors'}],\n     *     ],\n     *   },\n     * }\n     * ```\n     */\n    addCacheListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('message', ((event) => {\n            if (event.data && event.data.type === 'CACHE_URLS') {\n                const { payload } = event.data;\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n                }\n                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n                    if (typeof entry === 'string') {\n                        entry = [entry];\n                    }\n                    const request = new Request(...entry);\n                    return this.handleRequest({ request });\n                    // TODO(philipwalton): TypeScript errors without this typecast for\n                    // some reason (probably a bug). The real type here should work but\n                    // doesn't: `Array<Promise<Response> | undefined>`.\n                })); // TypeScript\n                event.waitUntil(requestPromises);\n                // If a MessageChannel was used, reply to the message on success.\n                if (event.ports && event.ports[0]) {\n                    requestPromises.then(() => event.ports[0].postMessage(true));\n                }\n            }\n        }));\n    }\n    /**\n     * Apply the routing rules to a FetchEvent object to get a Response from an\n     * appropriate Route's handler.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to handle (this is usually\n     *     from a fetch event, but it does not have to be).\n     * @param {FetchEvent} [options.event] The event that triggered the request,\n     *     if applicable.\n     * @return {Promise<Response>|undefined} A promise is returned if a\n     *     registered route can handle the request. If there is no matching\n     *     route and there's no `defaultHandler`, `undefined` is returned.\n     */\n    handleRequest({ request, event }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'handleRequest',\n                paramName: 'options.request',\n            });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith('http')) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n            }\n            return;\n        }\n        const { params, route } = this.findMatchingRoute({ url, request, event });\n        let handler = route && route.handler;\n        const debugMessages = [];\n        if (process.env.NODE_ENV !== 'production') {\n            if (handler) {\n                debugMessages.push([\n                    `Found a route to handle this request:`, route,\n                ]);\n                if (params) {\n                    debugMessages.push([\n                        `Passing the following params to the route's handler:`, params,\n                    ]);\n                }\n            }\n        }\n        // If we don't have a handler because there was no matching route, then\n        // fall back to defaultHandler if that's defined.\n        if (!handler && this._defaultHandler) {\n            if (process.env.NODE_ENV !== 'production') {\n                debugMessages.push(`Failed to find a matching route. Falling ` +\n                    `back to the default handler.`);\n            }\n            handler = this._defaultHandler;\n        }\n        if (!handler) {\n            if (process.env.NODE_ENV !== 'production') {\n                // No handler so Workbox will do nothing. If logs is set of debug\n                // i.e. verbose, we should print out this information.\n                logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n            }\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            // We have a handler, meaning Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n            debugMessages.forEach((msg) => {\n                if (Array.isArray(msg)) {\n                    logger.log(...msg);\n                }\n                else {\n                    logger.log(msg);\n                }\n            });\n            logger.groupEnd();\n        }\n        // Wrap in try and catch in case the handle method throws a synchronous\n        // error. It should still callback to the catch handler.\n        let responsePromise;\n        try {\n            responsePromise = handler.handle({ url, request, event, params });\n        }\n        catch (err) {\n            responsePromise = Promise.reject(err);\n        }\n        if (responsePromise instanceof Promise && this._catchHandler) {\n            responsePromise = responsePromise.catch((err) => {\n                if (process.env.NODE_ENV !== 'production') {\n                    // Still include URL here as it will be async from the console group\n                    // and may not make sense without the URL\n                    logger.groupCollapsed(`Error thrown when responding to: ` +\n                        ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\n                    logger.error(`Error thrown by:`, route);\n                    logger.error(err);\n                    logger.groupEnd();\n                }\n                return this._catchHandler.handle({ url, request, event });\n            });\n        }\n        return responsePromise;\n    }\n    /**\n     * Checks a request and URL (and optionally an event) against the list of\n     * registered routes, and if there's a match, returns the corresponding\n     * route along with any params generated by the match.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {Request} options.request The request to match.\n     * @param {Event} [options.event] The corresponding event (unless N/A).\n     * @return {Object} An object with `route` and `params` properties.\n     *     They are populated if a matching route was found or `undefined`\n     *     otherwise.\n     */\n    findMatchingRoute({ url, request, event }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(url, URL, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'findMatchingRoute',\n                paramName: 'options.url',\n            });\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'findMatchingRoute',\n                paramName: 'options.request',\n            });\n        }\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes) {\n            let params;\n            const matchResult = route.match({ url, request, event });\n            if (matchResult) {\n                // See https://github.com/GoogleChrome/workbox/issues/2079\n                params = matchResult;\n                if (Array.isArray(matchResult) && matchResult.length === 0) {\n                    // Instead of passing an empty array in as params, use undefined.\n                    params = undefined;\n                }\n                else if ((matchResult.constructor === Object &&\n                    Object.keys(matchResult).length === 0)) {\n                    // Instead of passing an empty object in as params, use undefined.\n                    params = undefined;\n                }\n                else if (typeof matchResult === 'boolean') {\n                    // For the boolean value true (rather than just something truth-y),\n                    // don't set params.\n                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n                    params = undefined;\n                }\n                // Return early if have a match.\n                return { route, params };\n            }\n        }\n        // If no match was found above, return and empty object.\n        return {};\n    }\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n    setDefaultHandler(handler) {\n        this._defaultHandler = normalizeHandler(handler);\n    }\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n    setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n    }\n    /**\n     * Registers a route with the router.\n     *\n     * @param {module:workbox-routing.Route} route The route to register.\n     */\n    registerRoute(route) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(route, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route, 'match', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.isType(route.handler, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route.handler, 'handle', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.handler',\n            });\n            assert.isType(route.method, 'string', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.method',\n            });\n        }\n        if (!this._routes.has(route.method)) {\n            this._routes.set(route.method, []);\n        }\n        // Give precedence to all of the earlier routes by adding this additional\n        // route to the end of the array.\n        this._routes.get(route.method).push(route);\n    }\n    /**\n     * Unregisters a route with the router.\n     *\n     * @param {module:workbox-routing.Route} route The route to unregister.\n     */\n    unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n            throw new WorkboxError('unregister-route-but-not-found-with-method', {\n                method: route.method,\n            });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n            this._routes.get(route.method).splice(routeIndex, 1);\n        }\n        else {\n            throw new WorkboxError('unregister-route-route-not-registered');\n        }\n    }\n}\nexport { Router };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}