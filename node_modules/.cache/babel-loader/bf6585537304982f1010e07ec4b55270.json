{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\n\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} [cacheName] An optional name for the cache, to override\n   * the default precache name.\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._urlsToCacheKeys = new Map();\n    this._urlsToCacheModes = new Map();\n    this._cacheKeysToIntegrities = new Map();\n  }\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to precache.\n   */\n\n\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries'\n      });\n    }\n\n    const urlsToWarnAbout = [];\n\n    for (const entry of entries) {\n      // See https://github.com/GoogleChrome/workbox/issues/2259\n      if (typeof entry === 'string') {\n        urlsToWarnAbout.push(entry);\n      } else if (entry && entry.revision === undefined) {\n        urlsToWarnAbout.push(entry.url);\n      }\n\n      const {\n        cacheKey,\n        url\n      } = createCacheKey(entry);\n      const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n\n      if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey\n        });\n      }\n\n      if (typeof entry !== 'string' && entry.integrity) {\n        if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n          throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n            url\n          });\n        }\n\n        this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n      }\n\n      this._urlsToCacheKeys.set(url, cacheKey);\n\n      this._urlsToCacheModes.set(url, cacheMode);\n\n      if (urlsToWarnAbout.length > 0) {\n        const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;\n\n        if (process.env.NODE_ENV === 'production') {\n          // Use console directly to display this warning without bloating\n          // bundle sizes by pulling in all of the logger codebase in prod.\n          console.warn(warningMessage);\n        } else {\n          logger.warn(warningMessage);\n        }\n      }\n    }\n  }\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * @param {Object} options\n   * @param {Event} [options.event] The install event (if needed).\n   * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n   * and caching during install.\n   * @return {Promise<module:workbox-precaching.InstallResult>}\n   */\n\n\n  async install() {\n    let {\n      event,\n      plugins\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (plugins) {\n        assert.isArray(plugins, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'install',\n          paramName: 'plugins'\n        });\n      }\n    }\n\n    const toBePrecached = [];\n    const alreadyPrecached = [];\n    const cache = await self.caches.open(this._cacheName);\n    const alreadyCachedRequests = await cache.keys();\n    const existingCacheKeys = new Set(alreadyCachedRequests.map(request => request.url));\n\n    for (const [url, cacheKey] of this._urlsToCacheKeys) {\n      if (existingCacheKeys.has(cacheKey)) {\n        alreadyPrecached.push(url);\n      } else {\n        toBePrecached.push({\n          cacheKey,\n          url\n        });\n      }\n    }\n\n    const precacheRequests = toBePrecached.map(_ref => {\n      let {\n        cacheKey,\n        url\n      } = _ref;\n\n      const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n\n      const cacheMode = this._urlsToCacheModes.get(url);\n\n      return this._addURLToCache({\n        cacheKey,\n        cacheMode,\n        event,\n        integrity,\n        plugins,\n        url\n      });\n    });\n    await Promise.all(precacheRequests);\n    const updatedURLs = toBePrecached.map(item => item.url);\n\n    if (process.env.NODE_ENV !== 'production') {\n      printInstallDetails(updatedURLs, alreadyPrecached);\n    }\n\n    return {\n      updatedURLs,\n      notUpdatedURLs: alreadyPrecached\n    };\n  }\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * @return {Promise<module:workbox-precaching.CleanupResult>}\n   */\n\n\n  async activate() {\n    const cache = await self.caches.open(this._cacheName);\n    const currentlyCachedRequests = await cache.keys();\n    const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n    const deletedURLs = [];\n\n    for (const request of currentlyCachedRequests) {\n      if (!expectedCacheKeys.has(request.url)) {\n        await cache.delete(request);\n        deletedURLs.push(request.url);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      printCleanupDetails(deletedURLs);\n    }\n\n    return {\n      deletedURLs\n    };\n  }\n  /**\n   * Requests the entry and saves it to the cache if the response is valid.\n   * By default, any response with a status code of less than 400 (including\n   * opaque responses) is considered valid.\n   *\n   * If you need to use custom criteria to determine what's valid and what\n   * isn't, then pass in an item in `options.plugins` that implements the\n   * `cacheWillUpdate()` lifecycle event.\n   *\n   * @private\n   * @param {Object} options\n   * @param {string} options.cacheKey The string to use a cache key.\n   * @param {string} options.url The URL to fetch and cache.\n   * @param {string} [options.cacheMode] The cache mode for the network request.\n   * @param {Event} [options.event] The install event (if passed).\n   * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n   * fetch and caching.\n   * @param {string} [options.integrity] The value to use for the `integrity`\n   * field when making the request.\n   */\n\n\n  async _addURLToCache(_ref2) {\n    let {\n      cacheKey,\n      url,\n      cacheMode,\n      event,\n      plugins,\n      integrity\n    } = _ref2;\n    const request = new Request(url, {\n      integrity,\n      cache: cacheMode,\n      credentials: 'same-origin'\n    });\n    let response = await fetchWrapper.fetch({\n      event,\n      plugins,\n      request\n    }); // Allow developers to override the default logic about what is and isn't\n    // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n    // a `CacheableResponsePlugin` instance.\n\n    let cacheWillUpdatePlugin;\n\n    for (const plugin of plugins || []) {\n      if ('cacheWillUpdate' in plugin) {\n        cacheWillUpdatePlugin = plugin;\n      }\n    }\n\n    const isValidResponse = cacheWillUpdatePlugin ? // Use a callback if provided. It returns a truthy value if valid.\n    // NOTE: invoke the method on the plugin instance so the `this` context\n    // is correct.\n    await cacheWillUpdatePlugin.cacheWillUpdate({\n      event,\n      request,\n      response\n    }) : // Otherwise, default to considering any response status under 400 valid.\n    // This includes, by default, considering opaque responses valid.\n    response.status < 400; // Consider this a failure, leading to the `install` handler failing, if\n    // we get back an invalid response.\n\n    if (!isValidResponse) {\n      throw new WorkboxError('bad-precaching-response', {\n        url,\n        status: response.status\n      });\n    } // Redirected responses cannot be used to satisfy a navigation request, so\n    // any redirected response must be \"copied\" rather than cloned, so the new\n    // response doesn't contain the `redirected` flag. See:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n\n\n    if (response.redirected) {\n      response = await copyResponse(response);\n    }\n\n    await cacheWrapper.put({\n      event,\n      plugins,\n      response,\n      // `request` already uses `url`. We may be able to reuse it.\n      request: cacheKey === url ? request : new Request(cacheKey),\n      cacheName: this._cacheName,\n      matchOptions: {\n        ignoreSearch: true\n      }\n    });\n  }\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n\n\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n\n\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n\n\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location.href);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n  /**\n   * This acts as a drop-in replacement for [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n   * with the following differences:\n   *\n   * - It knows what the name of the precache is, and only checks in that cache.\n   * - It allows you to pass in an \"original\" URL without versioning parameters,\n   * and it will automatically look up the correct cache key for the currently\n   * active revision of that URL.\n   *\n   * E.g., `matchPrecache('index.html')` will find the correct precached\n   * response for the currently active service worker, even if the actual cache\n   * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n   *\n   * @param {string|Request} request The key (without revisioning parameters)\n   * to look up in the precache.\n   * @return {Promise<Response|undefined>}\n   */\n\n\n  async matchPrecache(request) {\n    const url = request instanceof Request ? request.url : request;\n    const cacheKey = this.getCacheKeyForURL(url);\n\n    if (cacheKey) {\n      const cache = await self.caches.open(this._cacheName);\n      return cache.match(cacheKey);\n    }\n\n    return undefined;\n  }\n  /**\n   * Returns a function that can be used within a\n   * {@link module:workbox-routing.Route} that will find a response for the\n   * incoming request against the precache.\n   *\n   * If for an unexpected reason there is a cache miss for the request,\n   * this will fall back to retrieving the `Response` via `fetch()` when\n   * `fallbackToNetwork` is `true`.\n   *\n   * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n   * response from the network if there's a precache miss.\n   * @return {module:workbox-routing~handlerCallback}\n   */\n\n\n  createHandler() {\n    let fallbackToNetwork = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return async _ref3 => {\n      let {\n        request\n      } = _ref3;\n\n      try {\n        const response = await this.matchPrecache(request);\n\n        if (response) {\n          return response;\n        } // This shouldn't normally happen, but there are edge cases:\n        // https://github.com/GoogleChrome/workbox/issues/1441\n\n\n        throw new WorkboxError('missing-precache-entry', {\n          cacheName: this._cacheName,\n          url: request instanceof Request ? request.url : request\n        });\n      } catch (error) {\n        if (fallbackToNetwork) {\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Unable to respond with precached response. ` + `Falling back to network.`, error);\n          }\n\n          return fetch(request);\n        }\n\n        throw error;\n      }\n    };\n  }\n  /**\n   * Returns a function that looks up `url` in the precache (taking into\n   * account revision information), and returns the corresponding `Response`.\n   *\n   * If for an unexpected reason there is a cache miss when looking up `url`,\n   * this will fall back to retrieving the `Response` via `fetch()` when\n   * `fallbackToNetwork` is `true`.\n   *\n   * @param {string} url The precached URL which will be used to lookup the\n   * `Response`.\n   * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n   * response from the network if there's a precache miss.\n   * @return {module:workbox-routing~handlerCallback}\n   */\n\n\n  createHandlerBoundToURL(url) {\n    let fallbackToNetwork = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const cacheKey = this.getCacheKeyForURL(url);\n\n    if (!cacheKey) {\n      throw new WorkboxError('non-precached-url', {\n        url\n      });\n    }\n\n    const handler = this.createHandler(fallbackToNetwork);\n    const request = new Request(url);\n    return () => handler({\n      request\n    });\n  }\n\n}\n\nexport { PrecacheController };","map":{"version":3,"names":["assert","cacheNames","cacheWrapper","fetchWrapper","logger","WorkboxError","copyResponse","createCacheKey","printCleanupDetails","printInstallDetails","PrecacheController","constructor","cacheName","_cacheName","getPrecacheName","_urlsToCacheKeys","Map","_urlsToCacheModes","_cacheKeysToIntegrities","addToCacheList","entries","process","env","NODE_ENV","isArray","moduleName","className","funcName","paramName","urlsToWarnAbout","entry","push","revision","undefined","url","cacheKey","cacheMode","has","get","firstEntry","secondEntry","integrity","set","length","warningMessage","join","console","warn","install","event","plugins","toBePrecached","alreadyPrecached","cache","self","caches","open","alreadyCachedRequests","keys","existingCacheKeys","Set","map","request","precacheRequests","_addURLToCache","Promise","all","updatedURLs","item","notUpdatedURLs","activate","currentlyCachedRequests","expectedCacheKeys","values","deletedURLs","delete","Request","credentials","response","fetch","cacheWillUpdatePlugin","plugin","isValidResponse","cacheWillUpdate","status","redirected","put","matchOptions","ignoreSearch","getURLsToCacheKeys","getCachedURLs","getCacheKeyForURL","urlObject","URL","location","href","matchPrecache","match","createHandler","fallbackToNetwork","error","debug","createHandlerBoundToURL","handler"],"sources":["C:/Users/matth/Documents/careerfoundry/meet_app/meet/node_modules/workbox-precaching/PrecacheController.js"],"sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {string} [cacheName] An optional name for the cache, to override\n     * the default precache name.\n     */\n    constructor(cacheName) {\n        this._cacheName = cacheNames.getPrecacheName(cacheName);\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {\n     * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n     * } entries Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n            // See https://github.com/GoogleChrome/workbox/issues/2259\n            if (typeof entry === 'string') {\n                urlsToWarnAbout.push(entry);\n            }\n            else if (entry && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = (typeof entry !== 'string' && entry.revision) ?\n                'reload' : 'default';\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Workbox is precaching URLs without revision ` +\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\n                    `Learn more at https://bit.ly/wb-precache`;\n                if (process.env.NODE_ENV === 'production') {\n                    // Use console directly to display this warning without bloating\n                    // bundle sizes by pulling in all of the logger codebase in prod.\n                    console.warn(warningMessage);\n                }\n                else {\n                    logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * @param {Object} options\n     * @param {Event} [options.event] The install event (if needed).\n     * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n     * and caching during install.\n     * @return {Promise<module:workbox-precaching.InstallResult>}\n     */\n    async install({ event, plugins } = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (plugins) {\n                assert.isArray(plugins, {\n                    moduleName: 'workbox-precaching',\n                    className: 'PrecacheController',\n                    funcName: 'install',\n                    paramName: 'plugins',\n                });\n            }\n        }\n        const toBePrecached = [];\n        const alreadyPrecached = [];\n        const cache = await self.caches.open(this._cacheName);\n        const alreadyCachedRequests = await cache.keys();\n        const existingCacheKeys = new Set(alreadyCachedRequests.map((request) => request.url));\n        for (const [url, cacheKey] of this._urlsToCacheKeys) {\n            if (existingCacheKeys.has(cacheKey)) {\n                alreadyPrecached.push(url);\n            }\n            else {\n                toBePrecached.push({ cacheKey, url });\n            }\n        }\n        const precacheRequests = toBePrecached.map(({ cacheKey, url }) => {\n            const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n            const cacheMode = this._urlsToCacheModes.get(url);\n            return this._addURLToCache({\n                cacheKey,\n                cacheMode,\n                event,\n                integrity,\n                plugins,\n                url,\n            });\n        });\n        await Promise.all(precacheRequests);\n        const updatedURLs = toBePrecached.map((item) => item.url);\n        if (process.env.NODE_ENV !== 'production') {\n            printInstallDetails(updatedURLs, alreadyPrecached);\n        }\n        return {\n            updatedURLs,\n            notUpdatedURLs: alreadyPrecached,\n        };\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * @return {Promise<module:workbox-precaching.CleanupResult>}\n     */\n    async activate() {\n        const cache = await self.caches.open(this._cacheName);\n        const currentlyCachedRequests = await cache.keys();\n        const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n        const deletedURLs = [];\n        for (const request of currentlyCachedRequests) {\n            if (!expectedCacheKeys.has(request.url)) {\n                await cache.delete(request);\n                deletedURLs.push(request.url);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            printCleanupDetails(deletedURLs);\n        }\n        return { deletedURLs };\n    }\n    /**\n     * Requests the entry and saves it to the cache if the response is valid.\n     * By default, any response with a status code of less than 400 (including\n     * opaque responses) is considered valid.\n     *\n     * If you need to use custom criteria to determine what's valid and what\n     * isn't, then pass in an item in `options.plugins` that implements the\n     * `cacheWillUpdate()` lifecycle event.\n     *\n     * @private\n     * @param {Object} options\n     * @param {string} options.cacheKey The string to use a cache key.\n     * @param {string} options.url The URL to fetch and cache.\n     * @param {string} [options.cacheMode] The cache mode for the network request.\n     * @param {Event} [options.event] The install event (if passed).\n     * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n     * fetch and caching.\n     * @param {string} [options.integrity] The value to use for the `integrity`\n     * field when making the request.\n     */\n    async _addURLToCache({ cacheKey, url, cacheMode, event, plugins, integrity }) {\n        const request = new Request(url, {\n            integrity,\n            cache: cacheMode,\n            credentials: 'same-origin',\n        });\n        let response = await fetchWrapper.fetch({\n            event,\n            plugins,\n            request,\n        });\n        // Allow developers to override the default logic about what is and isn't\n        // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n        // a `CacheableResponsePlugin` instance.\n        let cacheWillUpdatePlugin;\n        for (const plugin of (plugins || [])) {\n            if ('cacheWillUpdate' in plugin) {\n                cacheWillUpdatePlugin = plugin;\n            }\n        }\n        const isValidResponse = cacheWillUpdatePlugin ?\n            // Use a callback if provided. It returns a truthy value if valid.\n            // NOTE: invoke the method on the plugin instance so the `this` context\n            // is correct.\n            await cacheWillUpdatePlugin.cacheWillUpdate({ event, request, response }) :\n            // Otherwise, default to considering any response status under 400 valid.\n            // This includes, by default, considering opaque responses valid.\n            response.status < 400;\n        // Consider this a failure, leading to the `install` handler failing, if\n        // we get back an invalid response.\n        if (!isValidResponse) {\n            throw new WorkboxError('bad-precaching-response', {\n                url,\n                status: response.status,\n            });\n        }\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        if (response.redirected) {\n            response = await copyResponse(response);\n        }\n        await cacheWrapper.put({\n            event,\n            plugins,\n            response,\n            // `request` already uses `url`. We may be able to reuse it.\n            request: cacheKey === url ? request : new Request(cacheKey),\n            cacheName: this._cacheName,\n            matchOptions: {\n                ignoreSearch: true,\n            },\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * This acts as a drop-in replacement for [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this._cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    /**\n     * Returns a function that can be used within a\n     * {@link module:workbox-routing.Route} that will find a response for the\n     * incoming request against the precache.\n     *\n     * If for an unexpected reason there is a cache miss for the request,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */\n    createHandler(fallbackToNetwork = true) {\n        return async ({ request }) => {\n            try {\n                const response = await this.matchPrecache(request);\n                if (response) {\n                    return response;\n                }\n                // This shouldn't normally happen, but there are edge cases:\n                // https://github.com/GoogleChrome/workbox/issues/1441\n                throw new WorkboxError('missing-precache-entry', {\n                    cacheName: this._cacheName,\n                    url: request instanceof Request ? request.url : request,\n                });\n            }\n            catch (error) {\n                if (fallbackToNetwork) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.debug(`Unable to respond with precached response. ` +\n                            `Falling back to network.`, error);\n                    }\n                    return fetch(request);\n                }\n                throw error;\n            }\n        };\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * If for an unexpected reason there is a cache miss when looking up `url`,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */\n    createHandlerBoundToURL(url, fallbackToNetwork = true) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        const handler = this.createHandler(fallbackToNetwork);\n        const request = new Request(url);\n        return () => handler({ request });\n    }\n}\nexport { PrecacheController };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}