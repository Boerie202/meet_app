{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\n\nexport class DBWrapper {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {!Function} [callbacks.onupgradeneeded]\n   * @param {!Function} [callbacks.onversionchange] Defaults to\n   *     DBWrapper.prototype._onversionchange when not specified.\n   * @private\n   */\n  constructor(name, version) {\n    let {\n      onupgradeneeded,\n      onversionchange\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this._db = null;\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n\n    this._onversionchange = onversionchange || (() => this.close());\n  }\n  /**\n   * Returns the IDBDatabase instance (not normally needed).\n   * @return {IDBDatabase|undefined}\n   *\n   * @private\n   */\n\n\n  get db() {\n    return this._db;\n  }\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   * @private\n   */\n\n\n  async open() {\n    if (this._db) return;\n    this._db = await new Promise((resolve, reject) => {\n      // This flag is flipped to true if the timeout callback runs prior\n      // to the request failing or succeeding. Note: we use a timeout instead\n      // of an onblocked handler since there are cases where onblocked will\n      // never never run. A timeout better handles all possible scenarios:\n      // https://github.com/w3c/IndexedDB/issues/223\n      let openRequestTimedOut = false;\n      setTimeout(() => {\n        openRequestTimedOut = true;\n        reject(new Error('The open request was blocked and timed out'));\n      }, this.OPEN_TIMEOUT);\n      const openRequest = indexedDB.open(this._name, this._version);\n\n      openRequest.onerror = () => reject(openRequest.error);\n\n      openRequest.onupgradeneeded = evt => {\n        if (openRequestTimedOut) {\n          openRequest.transaction.abort();\n          openRequest.result.close();\n        } else if (typeof this._onupgradeneeded === 'function') {\n          this._onupgradeneeded(evt);\n        }\n      };\n\n      openRequest.onsuccess = () => {\n        const db = openRequest.result;\n\n        if (openRequestTimedOut) {\n          db.close();\n        } else {\n          db.onversionchange = this._onversionchange.bind(this);\n          resolve(db);\n        }\n      };\n    });\n    return this;\n  }\n  /**\n   * Polyfills the native `getKey()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @return {Array}\n   * @private\n   */\n\n\n  async getKey(storeName, query) {\n    return (await this.getAllKeys(storeName, query, 1))[0];\n  }\n  /**\n   * Polyfills the native `getAll()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n\n\n  async getAll(storeName, query, count) {\n    return await this.getAllMatching(storeName, {\n      query,\n      count\n    });\n  }\n  /**\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n   * runtime if the browser supports the native method.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   * @private\n   */\n\n\n  async getAllKeys(storeName, query, count) {\n    const entries = await this.getAllMatching(storeName, {\n      query,\n      count,\n      includeKeys: true\n    });\n    return entries.map(entry => entry.key);\n  }\n  /**\n   * Supports flexible lookup in an object store by specifying an index,\n   * query, direction, and count. This method returns an array of objects\n   * with the signature .\n   *\n   * @param {string} storeName\n   * @param {Object} [opts]\n   * @param {string} [opts.index] The index to use (if specified).\n   * @param {*} [opts.query]\n   * @param {IDBCursorDirection} [opts.direction]\n   * @param {number} [opts.count] The max number of results to return.\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\n   *     returned objects is changed from an array of values to an array of\n   *     objects in the form {key, primaryKey, value}.\n   * @return {Array}\n   * @private\n   */\n\n\n  async getAllMatching(storeName) {\n    let {\n      index,\n      query = null,\n      // IE/Edge errors if query === `undefined`.\n      direction = 'next',\n      count,\n      includeKeys = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\n      const store = txn.objectStore(storeName);\n      const target = index ? store.index(index) : store;\n      const results = [];\n      const request = target.openCursor(query, direction);\n\n      request.onsuccess = () => {\n        const cursor = request.result;\n\n        if (cursor) {\n          results.push(includeKeys ? cursor : cursor.value);\n\n          if (count && results.length >= count) {\n            done(results);\n          } else {\n            cursor.continue();\n          }\n        } else {\n          done(results);\n        }\n      };\n    });\n  }\n  /**\n   * Accepts a list of stores, a transaction type, and a callback and\n   * performs a transaction. A promise is returned that resolves to whatever\n   * value the callback chooses. The callback holds all the transaction logic\n   * and is invoked with two arguments:\n   *   1. The IDBTransaction object\n   *   2. A `done` function, that's used to resolve the promise when\n   *      when the transaction is done, if passed a value, the promise is\n   *      resolved to that value.\n   *\n   * @param {Array<string>} storeNames An array of object store names\n   *     involved in the transaction.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {!Function} callback\n   * @return {*} The result of the transaction ran by the callback.\n   * @private\n   */\n\n\n  async transaction(storeNames, type, callback) {\n    await this.open();\n    return await new Promise((resolve, reject) => {\n      const txn = this._db.transaction(storeNames, type);\n\n      txn.onabort = () => reject(txn.error);\n\n      txn.oncomplete = () => resolve();\n\n      callback(txn, value => resolve(value));\n    });\n  }\n  /**\n   * Delegates async to a native IDBObjectStore method.\n   *\n   * @param {string} method The method name.\n   * @param {string} storeName The object store name.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {...*} args The list of args to pass to the native method.\n   * @return {*} The result of the transaction.\n   * @private\n   */\n\n\n  async _call(method, storeName, type) {\n    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      args[_key - 3] = arguments[_key];\n    }\n\n    const callback = (txn, done) => {\n      const objStore = txn.objectStore(storeName); // TODO(philipwalton): Fix this underlying TS2684 error.\n      // @ts-ignore\n\n      const request = objStore[method].apply(objStore, args);\n\n      request.onsuccess = () => done(request.result);\n    };\n\n    return await this.transaction([storeName], type, callback);\n  }\n  /**\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\n   * doesn't need to be called since:\n   *   1. It's usually better to keep a connection open since opening\n   *      a new connection is somewhat slow.\n   *   2. Connections are automatically closed when the reference is\n   *      garbage collected.\n   * The primary use case for needing to close a connection is when another\n   * reference (typically in another tab) needs to upgrade it and would be\n   * blocked by the current, open connection.\n   *\n   * @private\n   */\n\n\n  close() {\n    if (this._db) {\n      this._db.close();\n\n      this._db = null;\n    }\n  }\n\n} // Exposed on the prototype to let users modify the default timeout on a\n// per-instance or global basis.\n\nDBWrapper.prototype.OPEN_TIMEOUT = 2000; // Wrap native IDBObjectStore methods according to their mode.\n\nconst methodsToWrap = {\n  readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n  readwrite: ['add', 'put', 'clear', 'delete']\n};\n\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n  for (const method of methods) {\n    if (method in IDBObjectStore.prototype) {\n      // Don't use arrow functions here since we're outside of the class.\n      DBWrapper.prototype[method] = async function (storeName) {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        return await this._call(method, storeName, mode, ...args);\n      };\n    }\n  }\n}","map":{"version":3,"names":["DBWrapper","constructor","name","version","onupgradeneeded","onversionchange","_db","_name","_version","_onupgradeneeded","_onversionchange","close","db","open","Promise","resolve","reject","openRequestTimedOut","setTimeout","Error","OPEN_TIMEOUT","openRequest","indexedDB","onerror","error","evt","transaction","abort","result","onsuccess","bind","getKey","storeName","query","getAllKeys","getAll","count","getAllMatching","entries","includeKeys","map","entry","key","index","direction","txn","done","store","objectStore","target","results","request","openCursor","cursor","push","value","length","continue","storeNames","type","callback","onabort","oncomplete","_call","method","args","objStore","apply","prototype","methodsToWrap","readonly","readwrite","mode","methods","Object","IDBObjectStore"],"sources":["C:/Users/matth/Documents/careerfoundry/meet_app/meet/node_modules/workbox-core/_private/DBWrapper.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n    /**\n     * @param {string} name\n     * @param {number} version\n     * @param {Object=} [callback]\n     * @param {!Function} [callbacks.onupgradeneeded]\n     * @param {!Function} [callbacks.onversionchange] Defaults to\n     *     DBWrapper.prototype._onversionchange when not specified.\n     * @private\n     */\n    constructor(name, version, { onupgradeneeded, onversionchange, } = {}) {\n        this._db = null;\n        this._name = name;\n        this._version = version;\n        this._onupgradeneeded = onupgradeneeded;\n        this._onversionchange = onversionchange || (() => this.close());\n    }\n    /**\n     * Returns the IDBDatabase instance (not normally needed).\n     * @return {IDBDatabase|undefined}\n     *\n     * @private\n     */\n    get db() {\n        return this._db;\n    }\n    /**\n     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n     * callback, and added an onversionchange callback to the database.\n     *\n     * @return {IDBDatabase}\n     * @private\n     */\n    async open() {\n        if (this._db)\n            return;\n        this._db = await new Promise((resolve, reject) => {\n            // This flag is flipped to true if the timeout callback runs prior\n            // to the request failing or succeeding. Note: we use a timeout instead\n            // of an onblocked handler since there are cases where onblocked will\n            // never never run. A timeout better handles all possible scenarios:\n            // https://github.com/w3c/IndexedDB/issues/223\n            let openRequestTimedOut = false;\n            setTimeout(() => {\n                openRequestTimedOut = true;\n                reject(new Error('The open request was blocked and timed out'));\n            }, this.OPEN_TIMEOUT);\n            const openRequest = indexedDB.open(this._name, this._version);\n            openRequest.onerror = () => reject(openRequest.error);\n            openRequest.onupgradeneeded = (evt) => {\n                if (openRequestTimedOut) {\n                    openRequest.transaction.abort();\n                    openRequest.result.close();\n                }\n                else if (typeof this._onupgradeneeded === 'function') {\n                    this._onupgradeneeded(evt);\n                }\n            };\n            openRequest.onsuccess = () => {\n                const db = openRequest.result;\n                if (openRequestTimedOut) {\n                    db.close();\n                }\n                else {\n                    db.onversionchange = this._onversionchange.bind(this);\n                    resolve(db);\n                }\n            };\n        });\n        return this;\n    }\n    /**\n     * Polyfills the native `getKey()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @return {Array}\n     * @private\n     */\n    async getKey(storeName, query) {\n        return (await this.getAllKeys(storeName, query, 1))[0];\n    }\n    /**\n     * Polyfills the native `getAll()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n    async getAll(storeName, query, count) {\n        return await this.getAllMatching(storeName, { query, count });\n    }\n    /**\n     * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n    async getAllKeys(storeName, query, count) {\n        const entries = await this.getAllMatching(storeName, { query, count, includeKeys: true });\n        return entries.map((entry) => entry.key);\n    }\n    /**\n     * Supports flexible lookup in an object store by specifying an index,\n     * query, direction, and count. This method returns an array of objects\n     * with the signature .\n     *\n     * @param {string} storeName\n     * @param {Object} [opts]\n     * @param {string} [opts.index] The index to use (if specified).\n     * @param {*} [opts.query]\n     * @param {IDBCursorDirection} [opts.direction]\n     * @param {number} [opts.count] The max number of results to return.\n     * @param {boolean} [opts.includeKeys] When true, the structure of the\n     *     returned objects is changed from an array of values to an array of\n     *     objects in the form {key, primaryKey, value}.\n     * @return {Array}\n     * @private\n     */\n    async getAllMatching(storeName, { index, query = null, // IE/Edge errors if query === `undefined`.\n    direction = 'next', count, includeKeys = false, } = {}) {\n        return await this.transaction([storeName], 'readonly', (txn, done) => {\n            const store = txn.objectStore(storeName);\n            const target = index ? store.index(index) : store;\n            const results = [];\n            const request = target.openCursor(query, direction);\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (cursor) {\n                    results.push(includeKeys ? cursor : cursor.value);\n                    if (count && results.length >= count) {\n                        done(results);\n                    }\n                    else {\n                        cursor.continue();\n                    }\n                }\n                else {\n                    done(results);\n                }\n            };\n        });\n    }\n    /**\n     * Accepts a list of stores, a transaction type, and a callback and\n     * performs a transaction. A promise is returned that resolves to whatever\n     * value the callback chooses. The callback holds all the transaction logic\n     * and is invoked with two arguments:\n     *   1. The IDBTransaction object\n     *   2. A `done` function, that's used to resolve the promise when\n     *      when the transaction is done, if passed a value, the promise is\n     *      resolved to that value.\n     *\n     * @param {Array<string>} storeNames An array of object store names\n     *     involved in the transaction.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {!Function} callback\n     * @return {*} The result of the transaction ran by the callback.\n     * @private\n     */\n    async transaction(storeNames, type, callback) {\n        await this.open();\n        return await new Promise((resolve, reject) => {\n            const txn = this._db.transaction(storeNames, type);\n            txn.onabort = () => reject(txn.error);\n            txn.oncomplete = () => resolve();\n            callback(txn, (value) => resolve(value));\n        });\n    }\n    /**\n     * Delegates async to a native IDBObjectStore method.\n     *\n     * @param {string} method The method name.\n     * @param {string} storeName The object store name.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {...*} args The list of args to pass to the native method.\n     * @return {*} The result of the transaction.\n     * @private\n     */\n    async _call(method, storeName, type, ...args) {\n        const callback = (txn, done) => {\n            const objStore = txn.objectStore(storeName);\n            // TODO(philipwalton): Fix this underlying TS2684 error.\n            // @ts-ignore\n            const request = objStore[method].apply(objStore, args);\n            request.onsuccess = () => done(request.result);\n        };\n        return await this.transaction([storeName], type, callback);\n    }\n    /**\n     * Closes the connection opened by `DBWrapper.open()`. Generally this method\n     * doesn't need to be called since:\n     *   1. It's usually better to keep a connection open since opening\n     *      a new connection is somewhat slow.\n     *   2. Connections are automatically closed when the reference is\n     *      garbage collected.\n     * The primary use case for needing to close a connection is when another\n     * reference (typically in another tab) needs to upgrade it and would be\n     * blocked by the current, open connection.\n     *\n     * @private\n     */\n    close() {\n        if (this._db) {\n            this._db.close();\n            this._db = null;\n        }\n    }\n}\n// Exposed on the prototype to let users modify the default timeout on a\n// per-instance or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n    readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n    readwrite: ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n    for (const method of methods) {\n        if (method in IDBObjectStore.prototype) {\n            // Don't use arrow functions here since we're outside of the class.\n            DBWrapper.prototype[method] =\n                async function (storeName, ...args) {\n                    return await this._call(method, storeName, mode, ...args);\n                };\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}