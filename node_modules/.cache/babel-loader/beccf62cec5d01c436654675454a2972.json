{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\nconst _getEffectiveRequest = async _ref => {\n  let {\n    request,\n    mode,\n    plugins = []\n  } = _ref;\n  const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\"\n  /* CACHE_KEY_WILL_BE_USED */\n  );\n  let effectiveRequest = request;\n\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\n    effectiveRequest = await plugin[\"cacheKeyWillBeUsed\"\n    /* CACHE_KEY_WILL_BE_USED */\n    ].call(plugin, {\n      mode,\n      request: effectiveRequest\n    });\n\n    if (typeof effectiveRequest === 'string') {\n      effectiveRequest = new Request(effectiveRequest);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(effectiveRequest, Request, {\n        moduleName: 'Plugin',\n        funcName: \"cacheKeyWillBeUsed\"\n        /* CACHE_KEY_WILL_BE_USED */\n        ,\n        isReturnValueProblem: true\n      });\n    }\n  }\n\n  return effectiveRequest;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nconst _isResponseSafeToCache = async _ref2 => {\n  let {\n    request,\n    response,\n    event,\n    plugins = []\n  } = _ref2;\n  let responseToCache = response;\n  let pluginsUsed = false;\n\n  for (const plugin of plugins) {\n    if (\"cacheWillUpdate\"\n    /* CACHE_WILL_UPDATE */\n    in plugin) {\n      pluginsUsed = true;\n      const pluginMethod = plugin[\"cacheWillUpdate\"\n      /* CACHE_WILL_UPDATE */\n      ];\n      responseToCache = await pluginMethod.call(plugin, {\n        request,\n        response: responseToCache,\n        event\n      });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          assert.isInstance(responseToCache, Response, {\n            moduleName: 'Plugin',\n            funcName: \"cacheWillUpdate\"\n            /* CACHE_WILL_UPDATE */\n            ,\n            isReturnValueProblem: true\n          });\n        }\n      }\n\n      if (!responseToCache) {\n        break;\n      }\n    }\n  }\n\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (responseToCache) {\n        if (responseToCache.status !== 200) {\n          if (responseToCache.status === 0) {\n            logger.warn(`The response for '${request.url}' is an opaque ` + `response. The caching strategy that you're using will not ` + `cache opaque responses by default.`);\n          } else {\n            logger.debug(`The response for '${request.url}' returned ` + `a status code of '${response.status}' and won't be cached as a ` + `result.`);\n          }\n        }\n      }\n    }\n\n    responseToCache = responseToCache && responseToCache.status === 200 ? responseToCache : undefined;\n  }\n\n  return responseToCache ? responseToCache : null;\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nconst matchWrapper = async _ref3 => {\n  let {\n    cacheName,\n    request,\n    event,\n    matchOptions,\n    plugins = []\n  } = _ref3;\n  const cache = await self.caches.open(cacheName);\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins,\n    request,\n    mode: 'read'\n  });\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      logger.debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n\n  for (const plugin of plugins) {\n    if (\"cachedResponseWillBeUsed\"\n    /* CACHED_RESPONSE_WILL_BE_USED */\n    in plugin) {\n      const pluginMethod = plugin[\"cachedResponseWillBeUsed\"\n      /* CACHED_RESPONSE_WILL_BE_USED */\n      ];\n      cachedResponse = await pluginMethod.call(plugin, {\n        cacheName,\n        event,\n        matchOptions,\n        cachedResponse,\n        request: effectiveRequest\n      });\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n          assert.isInstance(cachedResponse, Response, {\n            moduleName: 'Plugin',\n            funcName: \"cachedResponseWillBeUsed\"\n            /* CACHED_RESPONSE_WILL_BE_USED */\n            ,\n            isReturnValueProblem: true\n          });\n        }\n      }\n    }\n  }\n\n  return cachedResponse;\n};\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nconst putWrapper = async _ref4 => {\n  let {\n    cacheName,\n    request,\n    response,\n    event,\n    plugins = [],\n    matchOptions\n  } = _ref4;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (request.method && request.method !== 'GET') {\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\n        url: getFriendlyURL(request.url),\n        method: request.method\n      });\n    }\n  }\n\n  const effectiveRequest = await _getEffectiveRequest({\n    plugins,\n    request,\n    mode: 'write'\n  });\n\n  if (!response) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);\n    }\n\n    throw new WorkboxError('cache-put-with-no-response', {\n      url: getFriendlyURL(effectiveRequest.url)\n    });\n  }\n\n  const responseToCache = await _isResponseSafeToCache({\n    event,\n    plugins,\n    response,\n    request: effectiveRequest\n  });\n\n  if (!responseToCache) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` + `not be cached.`, responseToCache);\n    }\n\n    return;\n  }\n\n  const cache = await self.caches.open(cacheName);\n  const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\"\n  /* CACHE_DID_UPDATE */\n  );\n  const oldResponse = updatePlugins.length > 0 ? await matchWrapper({\n    cacheName,\n    matchOptions,\n    request: effectiveRequest\n  }) : null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` + `${getFriendlyURL(effectiveRequest.url)}.`);\n  }\n\n  try {\n    await cache.put(effectiveRequest, responseToCache);\n  } catch (error) {\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n    if (error.name === 'QuotaExceededError') {\n      await executeQuotaErrorCallbacks();\n    }\n\n    throw error;\n  }\n\n  for (const plugin of updatePlugins) {\n    await plugin[\"cacheDidUpdate\"\n    /* CACHE_DID_UPDATE */\n    ].call(plugin, {\n      cacheName,\n      event,\n      oldResponse,\n      newResponse: responseToCache,\n      request: effectiveRequest\n    });\n  }\n};\n\nexport const cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper\n};","map":{"version":3,"names":["assert","executeQuotaErrorCallbacks","getFriendlyURL","logger","pluginUtils","WorkboxError","_getEffectiveRequest","request","mode","plugins","cacheKeyWillBeUsedPlugins","filter","effectiveRequest","plugin","call","Request","process","env","NODE_ENV","isInstance","moduleName","funcName","isReturnValueProblem","_isResponseSafeToCache","response","event","responseToCache","pluginsUsed","pluginMethod","Response","status","warn","url","debug","undefined","matchWrapper","cacheName","matchOptions","cache","self","caches","open","cachedResponse","match","putWrapper","method","error","updatePlugins","oldResponse","length","put","name","newResponse","cacheWrapper"],"sources":["C:/Users/matth/Documents/careerfoundry/meet_app/meet/node_modules/workbox-core/_private/cacheWrapper.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({ request, mode, plugins = [], }) => {\n    const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */);\n    let effectiveRequest = request;\n    for (const plugin of cacheKeyWillBeUsedPlugins) {\n        effectiveRequest = await plugin[\"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */].call(plugin, { mode, request: effectiveRequest });\n        if (typeof effectiveRequest === 'string') {\n            effectiveRequest = new Request(effectiveRequest);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(effectiveRequest, Request, {\n                moduleName: 'Plugin',\n                funcName: \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */,\n                isReturnValueProblem: true,\n            });\n        }\n    }\n    return effectiveRequest;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({ request, response, event, plugins = [], }) => {\n    let responseToCache = response;\n    let pluginsUsed = false;\n    for (const plugin of plugins) {\n        if (\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */ in plugin) {\n            pluginsUsed = true;\n            const pluginMethod = plugin[\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */];\n            responseToCache = await pluginMethod.call(plugin, {\n                request,\n                response: responseToCache,\n                event,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    assert.isInstance(responseToCache, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cacheWillUpdate\" /* CACHE_WILL_UPDATE */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n            if (!responseToCache) {\n                break;\n            }\n        }\n    }\n    if (!pluginsUsed) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (responseToCache) {\n                if (responseToCache.status !== 200) {\n                    if (responseToCache.status === 0) {\n                        logger.warn(`The response for '${request.url}' is an opaque ` +\n                            `response. The caching strategy that you're using will not ` +\n                            `cache opaque responses by default.`);\n                    }\n                    else {\n                        logger.debug(`The response for '${request.url}' returned ` +\n                            `a status code of '${response.status}' and won't be cached as a ` +\n                            `result.`);\n                    }\n                }\n            }\n        }\n        responseToCache = responseToCache && responseToCache.status === 200 ?\n            responseToCache : undefined;\n    }\n    return responseToCache ? responseToCache : null;\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({ cacheName, request, event, matchOptions, plugins = [], }) => {\n    const cache = await self.caches.open(cacheName);\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'read'\n    });\n    let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n    if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n            logger.debug(`Found a cached response in '${cacheName}'.`);\n        }\n        else {\n            logger.debug(`No cached response found in '${cacheName}'.`);\n        }\n    }\n    for (const plugin of plugins) {\n        if (\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */ in plugin) {\n            const pluginMethod = plugin[\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */];\n            cachedResponse = await pluginMethod.call(plugin, {\n                cacheName,\n                event,\n                matchOptions,\n                cachedResponse,\n                request: effectiveRequest,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (cachedResponse) {\n                    assert.isInstance(cachedResponse, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n        }\n    }\n    return cachedResponse;\n};\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({ cacheName, request, response, event, plugins = [], matchOptions, }) => {\n    if (process.env.NODE_ENV !== 'production') {\n        if (request.method && request.method !== 'GET') {\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n                url: getFriendlyURL(request.url),\n                method: request.method,\n            });\n        }\n    }\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'write'\n    });\n    if (!response) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Cannot cache non-existent response for ` +\n                `'${getFriendlyURL(effectiveRequest.url)}'.`);\n        }\n        throw new WorkboxError('cache-put-with-no-response', {\n            url: getFriendlyURL(effectiveRequest.url),\n        });\n    }\n    const responseToCache = await _isResponseSafeToCache({\n        event,\n        plugins,\n        response,\n        request: effectiveRequest,\n    });\n    if (!responseToCache) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n                `not be cached.`, responseToCache);\n        }\n        return;\n    }\n    const cache = await self.caches.open(cacheName);\n    const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\" /* CACHE_DID_UPDATE */);\n    const oldResponse = updatePlugins.length > 0 ?\n        await matchWrapper({ cacheName, matchOptions, request: effectiveRequest }) :\n        null;\n    if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n            `${getFriendlyURL(effectiveRequest.url)}.`);\n    }\n    try {\n        await cache.put(effectiveRequest, responseToCache);\n    }\n    catch (error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n            await executeQuotaErrorCallbacks();\n        }\n        throw error;\n    }\n    for (const plugin of updatePlugins) {\n        await plugin[\"cacheDidUpdate\" /* CACHE_DID_UPDATE */].call(plugin, {\n            cacheName,\n            event,\n            oldResponse,\n            newResponse: responseToCache,\n            request: effectiveRequest,\n        });\n    }\n};\nexport const cacheWrapper = {\n    put: putWrapper,\n    match: matchWrapper,\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,aAAvB;AACA,SAASC,0BAAT,QAA2C,iCAA3C;AACA,SAASC,cAAT,QAA+B,qBAA/B;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,SAASC,WAAT,QAA4B,yBAA5B;AACA,SAASC,YAAT,QAA6B,mBAA7B;AACA,OAAO,gBAAP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,oBAAoB,GAAG,cAA4C;EAAA,IAArC;IAAEC,OAAF;IAAWC,IAAX;IAAiBC,OAAO,GAAG;EAA3B,CAAqC;EACrE,MAAMC,yBAAyB,GAAGN,WAAW,CAACO,MAAZ,CAAmBF,OAAnB,EAA4B;EAAqB;EAAjD,CAAlC;EACA,IAAIG,gBAAgB,GAAGL,OAAvB;;EACA,KAAK,MAAMM,MAAX,IAAqBH,yBAArB,EAAgD;IAC5CE,gBAAgB,GAAG,MAAMC,MAAM,CAAC;IAAqB;IAAtB,CAAN,CAA0DC,IAA1D,CAA+DD,MAA/D,EAAuE;MAAEL,IAAF;MAAQD,OAAO,EAAEK;IAAjB,CAAvE,CAAzB;;IACA,IAAI,OAAOA,gBAAP,KAA4B,QAAhC,EAA0C;MACtCA,gBAAgB,GAAG,IAAIG,OAAJ,CAAYH,gBAAZ,CAAnB;IACH;;IACD,IAAII,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;MACvClB,MAAM,CAACmB,UAAP,CAAkBP,gBAAlB,EAAoCG,OAApC,EAA6C;QACzCK,UAAU,EAAE,QAD6B;QAEzCC,QAAQ,EAAE;QAAqB;QAFU;QAGzCC,oBAAoB,EAAE;MAHmB,CAA7C;IAKH;EACJ;;EACD,OAAOV,gBAAP;AACH,CAjBD;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMW,sBAAsB,GAAG,eAAuD;EAAA,IAAhD;IAAEhB,OAAF;IAAWiB,QAAX;IAAqBC,KAArB;IAA4BhB,OAAO,GAAG;EAAtC,CAAgD;EAClF,IAAIiB,eAAe,GAAGF,QAAtB;EACA,IAAIG,WAAW,GAAG,KAAlB;;EACA,KAAK,MAAMd,MAAX,IAAqBJ,OAArB,EAA8B;IAC1B,IAAI;IAAkB;IAAlB,GAA6CI,MAAjD,EAAyD;MACrDc,WAAW,GAAG,IAAd;MACA,MAAMC,YAAY,GAAGf,MAAM,CAAC;MAAkB;MAAnB,CAA3B;MACAa,eAAe,GAAG,MAAME,YAAY,CAACd,IAAb,CAAkBD,MAAlB,EAA0B;QAC9CN,OAD8C;QAE9CiB,QAAQ,EAAEE,eAFoC;QAG9CD;MAH8C,CAA1B,CAAxB;;MAKA,IAAIT,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;QACvC,IAAIQ,eAAJ,EAAqB;UACjB1B,MAAM,CAACmB,UAAP,CAAkBO,eAAlB,EAAmCG,QAAnC,EAA6C;YACzCT,UAAU,EAAE,QAD6B;YAEzCC,QAAQ,EAAE;YAAkB;YAFa;YAGzCC,oBAAoB,EAAE;UAHmB,CAA7C;QAKH;MACJ;;MACD,IAAI,CAACI,eAAL,EAAsB;QAClB;MACH;IACJ;EACJ;;EACD,IAAI,CAACC,WAAL,EAAkB;IACd,IAAIX,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;MACvC,IAAIQ,eAAJ,EAAqB;QACjB,IAAIA,eAAe,CAACI,MAAhB,KAA2B,GAA/B,EAAoC;UAChC,IAAIJ,eAAe,CAACI,MAAhB,KAA2B,CAA/B,EAAkC;YAC9B3B,MAAM,CAAC4B,IAAP,CAAa,qBAAoBxB,OAAO,CAACyB,GAAI,iBAAjC,GACP,4DADO,GAEP,oCAFL;UAGH,CAJD,MAKK;YACD7B,MAAM,CAAC8B,KAAP,CAAc,qBAAoB1B,OAAO,CAACyB,GAAI,aAAjC,GACR,qBAAoBR,QAAQ,CAACM,MAAO,6BAD5B,GAER,SAFL;UAGH;QACJ;MACJ;IACJ;;IACDJ,eAAe,GAAGA,eAAe,IAAIA,eAAe,CAACI,MAAhB,KAA2B,GAA9C,GACdJ,eADc,GACIQ,SADtB;EAEH;;EACD,OAAOR,eAAe,GAAGA,eAAH,GAAqB,IAA3C;AACH,CA/CD;AAgDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMS,YAAY,GAAG,eAAsE;EAAA,IAA/D;IAAEC,SAAF;IAAa7B,OAAb;IAAsBkB,KAAtB;IAA6BY,YAA7B;IAA2C5B,OAAO,GAAG;EAArD,CAA+D;EACvF,MAAM6B,KAAK,GAAG,MAAMC,IAAI,CAACC,MAAL,CAAYC,IAAZ,CAAiBL,SAAjB,CAApB;EACA,MAAMxB,gBAAgB,GAAG,MAAMN,oBAAoB,CAAC;IAChDG,OADgD;IACvCF,OADuC;IAC9BC,IAAI,EAAE;EADwB,CAAD,CAAnD;EAGA,IAAIkC,cAAc,GAAG,MAAMJ,KAAK,CAACK,KAAN,CAAY/B,gBAAZ,EAA8ByB,YAA9B,CAA3B;;EACA,IAAIrB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACvC,IAAIwB,cAAJ,EAAoB;MAChBvC,MAAM,CAAC8B,KAAP,CAAc,+BAA8BG,SAAU,IAAtD;IACH,CAFD,MAGK;MACDjC,MAAM,CAAC8B,KAAP,CAAc,gCAA+BG,SAAU,IAAvD;IACH;EACJ;;EACD,KAAK,MAAMvB,MAAX,IAAqBJ,OAArB,EAA8B;IAC1B,IAAI;IAA2B;IAA3B,GAAiEI,MAArE,EAA6E;MACzE,MAAMe,YAAY,GAAGf,MAAM,CAAC;MAA2B;MAA5B,CAA3B;MACA6B,cAAc,GAAG,MAAMd,YAAY,CAACd,IAAb,CAAkBD,MAAlB,EAA0B;QAC7CuB,SAD6C;QAE7CX,KAF6C;QAG7CY,YAH6C;QAI7CK,cAJ6C;QAK7CnC,OAAO,EAAEK;MALoC,CAA1B,CAAvB;;MAOA,IAAII,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;QACvC,IAAIwB,cAAJ,EAAoB;UAChB1C,MAAM,CAACmB,UAAP,CAAkBuB,cAAlB,EAAkCb,QAAlC,EAA4C;YACxCT,UAAU,EAAE,QAD4B;YAExCC,QAAQ,EAAE;YAA2B;YAFG;YAGxCC,oBAAoB,EAAE;UAHkB,CAA5C;QAKH;MACJ;IACJ;EACJ;;EACD,OAAOoB,cAAP;AACH,CApCD;AAqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,UAAU,GAAG,eAAgF;EAAA,IAAzE;IAAER,SAAF;IAAa7B,OAAb;IAAsBiB,QAAtB;IAAgCC,KAAhC;IAAuChB,OAAO,GAAG,EAAjD;IAAqD4B;EAArD,CAAyE;;EAC/F,IAAIrB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACvC,IAAIX,OAAO,CAACsC,MAAR,IAAkBtC,OAAO,CAACsC,MAAR,KAAmB,KAAzC,EAAgD;MAC5C,MAAM,IAAIxC,YAAJ,CAAiB,kCAAjB,EAAqD;QACvD2B,GAAG,EAAE9B,cAAc,CAACK,OAAO,CAACyB,GAAT,CADoC;QAEvDa,MAAM,EAAEtC,OAAO,CAACsC;MAFuC,CAArD,CAAN;IAIH;EACJ;;EACD,MAAMjC,gBAAgB,GAAG,MAAMN,oBAAoB,CAAC;IAChDG,OADgD;IACvCF,OADuC;IAC9BC,IAAI,EAAE;EADwB,CAAD,CAAnD;;EAGA,IAAI,CAACgB,QAAL,EAAe;IACX,IAAIR,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;MACvCf,MAAM,CAAC2C,KAAP,CAAc,yCAAD,GACR,IAAG5C,cAAc,CAACU,gBAAgB,CAACoB,GAAlB,CAAuB,IAD7C;IAEH;;IACD,MAAM,IAAI3B,YAAJ,CAAiB,4BAAjB,EAA+C;MACjD2B,GAAG,EAAE9B,cAAc,CAACU,gBAAgB,CAACoB,GAAlB;IAD8B,CAA/C,CAAN;EAGH;;EACD,MAAMN,eAAe,GAAG,MAAMH,sBAAsB,CAAC;IACjDE,KADiD;IAEjDhB,OAFiD;IAGjDe,QAHiD;IAIjDjB,OAAO,EAAEK;EAJwC,CAAD,CAApD;;EAMA,IAAI,CAACc,eAAL,EAAsB;IAClB,IAAIV,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;MACvCf,MAAM,CAAC8B,KAAP,CAAc,aAAY/B,cAAc,CAACU,gBAAgB,CAACoB,GAAlB,CAAuB,SAAlD,GACR,gBADL,EACsBN,eADtB;IAEH;;IACD;EACH;;EACD,MAAMY,KAAK,GAAG,MAAMC,IAAI,CAACC,MAAL,CAAYC,IAAZ,CAAiBL,SAAjB,CAApB;EACA,MAAMW,aAAa,GAAG3C,WAAW,CAACO,MAAZ,CAAmBF,OAAnB,EAA4B;EAAiB;EAA7C,CAAtB;EACA,MAAMuC,WAAW,GAAGD,aAAa,CAACE,MAAd,GAAuB,CAAvB,GAChB,MAAMd,YAAY,CAAC;IAAEC,SAAF;IAAaC,YAAb;IAA2B9B,OAAO,EAAEK;EAApC,CAAD,CADF,GAEhB,IAFJ;;EAGA,IAAII,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACvCf,MAAM,CAAC8B,KAAP,CAAc,iBAAgBG,SAAU,kCAA3B,GACR,GAAElC,cAAc,CAACU,gBAAgB,CAACoB,GAAlB,CAAuB,GAD5C;EAEH;;EACD,IAAI;IACA,MAAMM,KAAK,CAACY,GAAN,CAAUtC,gBAAV,EAA4Bc,eAA5B,CAAN;EACH,CAFD,CAGA,OAAOoB,KAAP,EAAc;IACV;IACA,IAAIA,KAAK,CAACK,IAAN,KAAe,oBAAnB,EAAyC;MACrC,MAAMlD,0BAA0B,EAAhC;IACH;;IACD,MAAM6C,KAAN;EACH;;EACD,KAAK,MAAMjC,MAAX,IAAqBkC,aAArB,EAAoC;IAChC,MAAMlC,MAAM,CAAC;IAAiB;IAAlB,CAAN,CAAgDC,IAAhD,CAAqDD,MAArD,EAA6D;MAC/DuB,SAD+D;MAE/DX,KAF+D;MAG/DuB,WAH+D;MAI/DI,WAAW,EAAE1B,eAJkD;MAK/DnB,OAAO,EAAEK;IALsD,CAA7D,CAAN;EAOH;AACJ,CA9DD;;AA+DA,OAAO,MAAMyC,YAAY,GAAG;EACxBH,GAAG,EAAEN,UADmB;EAExBD,KAAK,EAAER;AAFiB,CAArB"},"metadata":{},"sourceType":"module"}